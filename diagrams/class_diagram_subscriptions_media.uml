@startuml
title SSES - Core Class Diagram (Full Capability - Subscriptions + Media Weights)

skinparam classAttributeIconSize 0

'========================
' Kernel / Time
'========================
class WorldKernel {
  +seed: long
  +clock: SimClock
  +step(dt: Duration)
  +schedule(e: Event)
  +replay(runId: string)
}

class SimClock {
  +t: long
  +day: int
  +tick: long
  +advance(dt: Duration)
}

abstract class Event {
  +id: string
  +timestamp: long
  +apply(ctx: WorldContext)
}

class EventScheduler {
  +enqueue(e: Event)
  +next(): Event
}

class DeterministicReplay {
  +record(e: Event)
  +load(runId: string)
}

class WorldContext {
  +agents: AgentPopulation
  +gsr: GlobalSocialReality
  +networks: NetworkManager
  +subscriptions: SubscriptionService
  +content: ContentStore
  +physical: PhysicalWorld
  +stimuli: StimulusStore
  +analytics: Analytics
  +rng: RNG
}

WorldKernel --> SimClock
WorldKernel --> EventScheduler
WorldKernel --> DeterministicReplay
WorldKernel --> WorldContext

'========================
' Agents
'========================
class Agent {
  +id: AgentId
  +identity: IdentityState
  +beliefs: BeliefStore
  +emotion: EmotionState
  +budgets: BudgetState
  +personality: RewardWeights
  +memory: MemoryStore
  +attention: AttentionSystem
  +policy: ActionPolicy
  +learn: BanditLearner
  +tick(ctx: WorldContext)
  +perceive(p: Percept)
  +maybeAct(ctx: WorldContext): Action?
  +consolidateDaily(ctx: WorldContext)
}

class AgentPopulation {
  +agents: Map<AgentId, Agent>
  +get(id: AgentId): Agent
  +replace(exited: AgentId, newborn: Agent)
}

class IdentityState {
  +identity_vector: float[8..16]
  +identity_rigidity: float
  +ingroup_labels: Set<String>
  +taboo_boundaries: Set<String>
}

class BeliefStore {
  +topics: Map<TopicId, TopicBelief>
  +get(t: TopicId): TopicBelief
  +update(t: TopicId, delta: BeliefDelta)
}

class TopicBelief {
  +topic: TopicId
  +stance: float  '[-1,+1]
  +confidence: float  '[0,1]
  +salience: float  '[0,1]
  +knowledge: float  '[0,1]
}

class EmotionState {
  +valence: float
  +arousal: float
  +anger: float?
  +anxiety: float?
}

class BudgetState {
  +attention_minutes: float
  +action_budget: float
  +deep_focus_budget: float
  +risk_budget: float
  +regenDaily()
  +spend(kind: BudgetKind, amount: float): bool
}

class RewardWeights {
  +status: float
  +affiliation: float
  +dominance: float
  +coherence: float
  +novelty: float
  +safety: float
  +effortCost: float  'negative
}

AgentPopulation o-- Agent
Agent *-- IdentityState
Agent *-- BeliefStore
Agent *-- EmotionState
Agent *-- BudgetState
Agent *-- RewardWeights

'========================
' Attention: Consumption vs Interaction (Media-weighted)
'========================
class AttentionSystem {
  +scout: ScrollOrSeekner
  +deep: DeepFocusEngine
  +mediaParams: MediaBehaviorModel
  +evaluate(percepts: List<Percept>): List<Impression>
  +shouldDeepFocus(imps: List<Impression>): bool
  +deepFocus(target: ContentItem): DeepResult
}

class ScrollOrSeekner {
  +scan(item: ContentItem): Impression
}

class DeepFocusEngine {
  +analyze(item: ContentItem, ctx: FocusContext): DeepResult
}

enum IntakeMode {
  scroll
  seek
  physical
}

enum MediaType {
  news
  social_post
  video
  meme
  longform
  forum_thread
}

class MediaBehaviorModel {
  +consume_bias: Map<MediaType,float>        '[0,1] baseline read/see/watch
  +interact_bias: Map<MediaType,float>       '[0,1] baseline like/comment/share
  +deep_focus_bias: Map<MediaType,float>     '[0,1] baseline deep focus likelihood
  +action_type_priors: Map<MediaType,Map<InteractionType,float>>
}

class Impression {
  +intake_mode: IntakeMode
  +contentId: ContentId
  +media_type: MediaType
  +topic: TopicId?
  +valence: float
  +arousal: float
  +stance_signal: float
  +credibility: float
  +identity_threat: float
  +social_proof: float
  +source_strength: float
  +consumed_prob: float     '[0,1]
  +interact_prob: float     '[0,1]
  +decay()
}

class DeepResult {
  +arguments: Map<TopicId, float>
  +callToAction: ActionTemplate?
  +coordination: boolean
}

Agent --> AttentionSystem
AttentionSystem --> ScrollOrSeekner
AttentionSystem --> DeepFocusEngine
AttentionSystem --> MediaBehaviorModel

'========================
' Policy + Learning
'========================
class ActionPolicy {
  +selectIntent(a: Agent, ctx: WorldContext): Intent
  +selectActionTemplate(intent: Intent): ActionTemplate
  +instantiate(tpl: ActionTemplate, ctx: WorldContext): Action
  +chooseInteractionType(imp: Impression): InteractionType
}

class BanditLearner {
  +update(context: BanditContext, chosen: ActionTemplate, reward: RewardVector)
  +choose(context: BanditContext, candidates: List<ActionTemplate>): ActionTemplate
}

class RewardVector {
  +status: float
  +affiliation: float
  +dominance: float
  +coherence: float
  +novelty: float
  +safety: float
  +effortCost: float
  +weightedSum(w: RewardWeights): float
}

Agent --> ActionPolicy
Agent --> BanditLearner
BanditLearner --> RewardVector

'========================
' Social Reality + Online Networks
'========================
class GlobalSocialReality {
  +R: Map<Pair<AgentId,AgentId>, RelationshipVector>
  +get(u: AgentId, v: AgentId): RelationshipVector
  +update(u: AgentId, v: AgentId, delta: RelDelta)
}

class RelationshipVector {
  +affinity: float
  +trust: float
  +intimacy: float
  +conflict: float
  +reciprocity: float
  +status_delta: float
  +topic_alignment: Map<TopicId,float>
}

'---- Subscriptions (opt-in feed semantics)
enum SubscriptionType {
  creator
  topic
  outlet
  community
}

class Subscription {
  +subscriber: AgentId
  +type: SubscriptionType
  +targetId: String      'CreatorId / TopicId / OutletId / CommunityId
  +strength: float       '[0,1] how strongly opted-in
  +created_tick: long
}

class SubscriptionService {
  +subs_by_agent: Map<AgentId,List<Subscription>>
  +subscribers_by_target: Map<Pair<SubscriptionType,String>,Set<AgentId>>
  +getSubs(a: AgentId): List<Subscription>
  +isSubscribed(a: AgentId, type: SubscriptionType, targetId: String): bool
  +subscribe(a: AgentId, type: SubscriptionType, targetId: String, strength: float)
  +unsubscribe(a: AgentId, type: SubscriptionType, targetId: String)
}

'---- Content + delivery pipeline
class ContentStore {
  +content_by_id: Map<ContentId,ContentItem>
  +recent_by_author: Map<AgentId,Deque<ContentId>>
  +recent_by_topic: Map<TopicId,Deque<ContentId>>
  +recent_by_outlet: Map<OutletId,Deque<ContentId>>
  +add(item: ContentItem)
  +get(id: ContentId): ContentItem
  +queryByAuthor(a: AgentId, sinceTick: long): List<ContentId>
  +queryByTopic(t: TopicId, sinceTick: long): List<ContentId>
}

class DeliveryRecord {
  +tick: long
  +viewer: AgentId
  +layer_id: NetworkId
  +intake_mode: IntakeMode
  +eligible: List<ContentId>
  +shown: List<ContentId>
  +seen: List<ContentId>
  +media_breakdown: Map<MediaType,int>
}

abstract class NetworkLayer {
  +id: NetworkId
  +mechanics: PlatformMechanics
  +publish(interaction: Interaction, ctx: WorldContext)
  +deliver(viewer: AgentId, intake: IntakeMode, ctx: WorldContext): List<ContentItem>
}

class BroadcastFeedNetwork {
  +candidateWindowTicks: long
  +maxCandidates: int
  +maxShown: int
  +buildCandidates(viewer: AgentId, subs: List<Subscription>, ctx: WorldContext): List<ContentId>
  +rank(viewer: AgentId, candidates: List<ContentId>, ctx: WorldContext): List<ContentId>
}

class DirectMessageNetwork {
  +inboxes: Map<AgentId,Deque<ContentId>>
  +send(from: AgentId, to: AgentId, item: ContentItem)
  +deliver(viewer: AgentId, intake: IntakeMode, ctx: WorldContext): List<ContentItem>
}

class PlatformMechanics {
  +visibilityRules: VisibilityRules
  +rankingModel: RankingModel
  +riskProfile: RiskProfile
  +rewardMapping: RewardMapping
  +mediaPolicy: MediaPolicy
}

class MediaPolicy {
  +media_behavior: MediaBehaviorModel
  +format_costs: Map<MediaType,float>    'effort to produce
  +friction: Map<InteractionType,Map<MediaType,float>>  'UI friction
}

class NetworkManager {
  +layers: Map<NetworkId,NetworkLayer>
  +getLayer(id: NetworkId): NetworkLayer
}

NetworkLayer <|-- BroadcastFeedNetwork
NetworkLayer <|-- DirectMessageNetwork
NetworkLayer *-- PlatformMechanics
NetworkManager o-- NetworkLayer

WorldContext --> SubscriptionService
WorldContext --> ContentStore
BroadcastFeedNetwork --> SubscriptionService : expand subscriptions into candidates
BroadcastFeedNetwork --> ContentStore : retrieve content
BroadcastFeedNetwork --> GlobalSocialReality : trust/affinity signals
DirectMessageNetwork --> ContentStore

Agent --> GlobalSocialReality : updates via interactions

'========================
' Physical Layer
'========================
class PhysicalWorld {
  +places: Map<PlaceId, Place>
  +schedules: Map<AgentId, Schedule>
  +generateInteractions(day: int): List<PhysicalInteraction>
}

class Place {
  +id: PlaceId
  +size: int
  +mixingRate: float
  +norms: NormProfile
  +topicBias: Map<TopicId,float>
}

class Schedule {
  +memberships: List<PlaceId>
  +dailyPlan(day: int): List<PlaceVisit>
}

class PlaceVisit {
  +placeId: PlaceId
  +start: long
  +end: long
}

class PhysicalInteraction {
  +participants: List<AgentId>
  +topic: TopicId?
  +type: InteractionType
  +intensity: float
  +applyInfluence(gsr: GlobalSocialReality)
}

PhysicalWorld o-- Place
PhysicalWorld o-- Schedule
Schedule o-- PlaceVisit
PhysicalWorld --> PhysicalInteraction
PhysicalInteraction --> GlobalSocialReality

'========================
' Stimuli + Content
'========================
class StimulusStore {
  +items: List<ExternalStimulus>
  +getAt(t: long): List<ExternalStimulus>
}

class ExternalStimulus {
  +id: StimulusId
  +timestamp: long
  +source: String
  +payload: bytes
}

class ProvenanceTransformer {
  +transform(s: ExternalStimulus): List<ContentItem>
}

class ContentItem {
  +id: ContentId
  +timestamp: long
  +author: AgentId?
  +outlet: OutletId?
  +community: CommunityId?
  +media_type: MediaType
  +topics: List<TopicId>
  +stance: float?
  +emotionDerivative: float?
  +provenance: ProvenanceRecord
  +engagement: EngagementCounters
}

class EngagementCounters {
  +views: int
  +likes: int
  +reshares: int
  +replies: int
  +bookmarks: int
}

class ProvenanceRecord {
  +rootStimulusId: StimulusId
  +transformChain: List<String>
}

StimulusStore o-- ExternalStimulus
ProvenanceTransformer --> ContentItem
ContentItem *-- ProvenanceRecord
ContentItem *-- EngagementCounters
WorldContext --> StimulusStore

'========================
' Belief Update + Crossing + Attribution (unchanged)
'========================
class BeliefUpdateEngine {
  +update(a: Agent, imp: Impression, ctx: WorldContext): BeliefDelta
  +boundedAdjust(b: TopicBelief, delta: BeliefDelta): TopicBelief
}

class BeliefCrossingDetector {
  +check(a: Agent, topic: TopicId, before: TopicBelief, after: TopicBelief): BeliefCrossingEvent?
}

class AttributionEngine {
  +windowDaysMin: int
  +windowDaysMax: int
  +assignCredit(e: BeliefCrossingEvent, history: ExposureHistory): AttributionSet
}

class ExposureHistory {
  +events: List<ExposureEvent>
  +query(a: AgentId, topic: TopicId, since: long): List<ExposureEvent>
}

class ExposureEvent {
  +timestamp: long
  +agent: AgentId
  +contentId: ContentId
  +sourceActor: ActorId
  +channel: ChannelType
  +tieStrength: float
  +intake_mode: IntakeMode
  +media_type: MediaType
}

class BeliefCrossingEvent {
  +id: string
  +timestamp: long
  +agent: AgentId
  +topic: TopicId
  +prior: TopicBelief
  +after: TopicBelief
  +attribution: AttributionSet
}

class AttributionSet { +credits: List<AttributionCredit> }

class AttributionCredit {
  +source: ActorId
  +weight: float
  +channelMultiplier: float
  +recencyWeight: float
}

Agent --> BeliefUpdateEngine
BeliefUpdateEngine --> BeliefCrossingDetector
BeliefCrossingDetector --> BeliefCrossingEvent
AttributionEngine --> AttributionSet
ExposureHistory o-- ExposureEvent
BeliefCrossingEvent *-- AttributionSet
AttributionSet o-- AttributionCredit

'========================
' Analytics + Logging (add delivery + media metrics)
'========================
class Analytics {
  +logDelivery(r: DeliveryRecord)
  +logExposure(e: ExposureEvent)
  +logImpression(i: Impression)
  +logAction(a: Action)
  +logReward(r: RewardVector)
  +logBeliefUpdate(d: BeliefDelta)
  +logCrossing(e: BeliefCrossingEvent)
  +reportMetrics(): MetricsReport
}

Analytics --> DeliveryRecord
Analytics --> ExposureEvent
Analytics --> Impression

@enduml
